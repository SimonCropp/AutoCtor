using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace AutoCtor;

[Generator(LanguageNames.CSharp)]
public class AutoConstructSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new AutoConstructSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var receiver = (AutoConstructSyntaxReceiver)context.SyntaxContextReceiver;

        foreach (var type in receiver.ClassesToAutoConstruct)
        {
            var ns = type.ContainingNamespace.IsGlobalNamespace
                ? null
                : type.ContainingNamespace.ToString();

            var fields = type.GetMembers()
                .OfType<IFieldSymbol>()
                .Where(f => f.IsReadOnly);

            var parameters = fields.Select(f => $"{f.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {CreateFriendlyName(f.Name)}");

            var source = new CodeBuilder();
            source.AppendLine($"//------------------------------------------------------------------------------");
            source.AppendLine($"// <auto-generated>");
            source.AppendLine($"//     This code was generated by https://github.com/distantcam/AutoCtor");
            source.AppendLine($"//");
            source.AppendLine($"//     Changes to this file may cause incorrect behavior and will be lost if");
            source.AppendLine($"//     the code is regenerated.");
            source.AppendLine($"// </auto-generated>");
            source.AppendLine($"//------------------------------------------------------------------------------");
            source.AppendLine($"");

            if (ns is not null)
            {
                source.AppendLine($"namespace {ns}");
                source.AppendLine($"{{");
                source.IncreaseIndent();
            }

            source.AppendLine($"partial class {type.Name}");
            source.AppendLine($"{{");
            source.IncreaseIndent();

            source.AppendLine($"public {type.Name}({string.Join(", ", parameters)})");
            source.AppendLine($"{{");
            source.IncreaseIndent();

            foreach (var item in fields)
            {
                source.AppendLine($"this.{item.Name} = {CreateFriendlyName(item.Name)};");
            }

            source.DecreaseIndent();
            source.AppendLine($"}}");

            source.DecreaseIndent();
            source.AppendLine($"}}");

            if (ns is not null)
            {
                source.DecreaseIndent();
                source.AppendLine($"}}");
            }

            var typeNamespace = type.ContainingNamespace.IsGlobalNamespace
                ? null
                : $"{type.ContainingNamespace}.";

            context.AddSource($"{typeNamespace}{type.Name}.g.cs", SourceText.From(source.ToString(), Encoding.UTF8));
        }
    }

    private static string CreateFriendlyName(string name)
    {
        if (name.Length > 1 && name[0] == '_')
        {
            // Chop off the underscore at the start
            return name.Substring(1);
        }

        return name;
    }
}

public class AutoConstructSyntaxReceiver : ISyntaxContextReceiver
{
    public List<INamedTypeSymbol> ClassesToAutoConstruct { get; } = new();

    public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
    {
        if (context.Node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax)
        {
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax);
            var attributeData = classSymbol?.GetAttributes().SingleOrDefault(x =>
                (x.AttributeClass.Name == "AutoConstruct" || x.AttributeClass.Name == "AutoConstructAttribute") &&
                (x.AttributeClass.ContainingNamespace.IsGlobalNamespace || x.AttributeClass.ContainingNamespace.ToDisplayString() == "AutoCtor")
            );

            if (classSymbol is not null && attributeData is not null)
            {
                ClassesToAutoConstruct.Add((INamedTypeSymbol)classSymbol);
            }
        }
    }
}
